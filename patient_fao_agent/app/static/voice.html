<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Medilligence â€¢ AI Patient Education (Voice)</title>

<style>
* { margin: 0; padding: 0; box-sizing: border-box; }

body {
    font-family: "Segoe UI", system-ui, sans-serif;
    background: #f4f7fb;
    height: 100vh;
    display: flex;
    justify-content: center;
    align-items: center;
}

.container {
    width: 90%;
    max-width: 820px;
    height: 92vh;
    background: white;
    border-radius: 18px;
    box-shadow: 0 18px 40px rgba(0,0,0,0.12);
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

.header {
    background: #2563eb;
    color: white;
    padding: 16px 20px;
    display: flex;
    align-items: center;
    justify-content: space-between;
}

.header-left h1 {
    font-size: 18px;
    font-weight: 600;
}

.header-left p {
    font-size: 12px;
    opacity: 0.9;
}

.header-right button {
    background: transparent;
    border: none;
    color: white;
    font-size: 18px;
    cursor: pointer;
}

.verify-section {
    flex: 1;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    gap: 14px;
}

.input-group {
    width: 100%;
    max-width: 360px;
}

.input-group label {
    display: block;
    margin-bottom: 6px;
    font-weight: 500;
}

.input-group input {
    width: 100%;
    padding: 12px;
    border-radius: 8px;
    border: 1px solid #d1d5db;
}

.btn-primary {
    padding: 12px 28px;
    background: #2563eb;
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
}

.voice-section {
    display: none;
    flex-direction: column;
    flex: 1;
    min-height: 0;
}

.patient-info {
    padding: 10px 16px;
    background: #f1f5f9;
    font-size: 13px;
}

.conversation {
    flex: 1;
    padding: 20px;
    background: #f9fafb;
    overflow-y: auto;
}

.message {
    display: flex;
    margin-bottom: 14px;
}

.message.user { justify-content: flex-end; }
.message.assistant { justify-content: flex-start; }

.message-content {
    max-width: 70%;
    padding: 12px 16px;
    border-radius: 16px;
    font-size: 14px;
    line-height: 1.5;
}

.message.user .message-content {
    background: #2563eb;
    color: white;
    border-bottom-right-radius: 4px;
}

.message.assistant .message-content {
    background: #eef2f7;
    color: #1f2937;
    border-bottom-left-radius: 4px;
}

.voice-controls {
    padding: 20px;
    border-top: 1px solid #e5e7eb;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 16px;
}

.transcript-preview {
    width: 100%;
    max-width: 600px;
    min-height: 48px;
    padding: 12px;
    background: #f8fafc;
    border-radius: 10px;
    font-size: 14px;
    text-align: center;
    color: #374151;
}

.mic-button {
    width: 90px;
    height: 90px;
    border-radius: 50%;
    background: #2563eb;
    color: white;
    font-size: 36px;
    border: none;
    cursor: pointer;
}

.mic-button.listening {
    animation: pulse 1.5s infinite;
}

@keyframes pulse {
    0% { box-shadow: 0 0 0 0 rgba(37,99,235,0.6); }
    70% { box-shadow: 0 0 0 18px rgba(37,99,235,0); }
    100% { box-shadow: 0 0 0 0 rgba(37,99,235,0); }
}

.status-text {
    font-size: 13px;
    color: #6b7280;
}

.upload-area { display: none; }
#fileInput { display: none; }

.upload-trigger {
    width: 42px;
    height: 42px;
    border-radius: 50%;
    background: #e0e7ff;
    border: none;
    font-size: 18px;
    color: #2563eb;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
}

.loading, .error {
    padding: 8px;
    font-size: 13px;
}

.error { color: #dc2626; }
.loading { color: #2563eb; }
</style>
</head>

<body>

<div class="container">
    <div class="header">
        <div class="header-left">
            <h1>Medilligence</h1>
            <p>AI Patient Education â€¢ Voice</p>
        </div>
        <div class="header-right">
            <button onclick="goToChat()">ðŸ’¬</button>
        </div>
    </div>

    <div class="verify-section" id="verifySection">
        <div class="input-group">
            <label for="mobileNumber">Enter your mobile number</label>
            <input type="tel" id="mobileNumber" placeholder="+91 1234567890">
        </div>
        <button class="btn-primary" onclick="verifyPatient()">Verify & Continue</button>
        <div id="verifyMessage"></div>
    </div>

    <div class="voice-section" id="voiceSection">
        <div class="patient-info" id="patientInfo"></div>

        <div class="conversation" id="conversation"></div>

        <div class="upload-area">
            <button id="uploadBtn"></button>
            <input type="file" id="fileInput" accept=".pdf">
            <div id="uploadStatus"></div>
        </div>

        <div class="voice-controls">
            <button class="upload-trigger"
                    onclick="document.getElementById('fileInput').click()">
                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="currentColor" viewBox="0 0 16 16">
                    <path d="M4.5 3a2.5 2.5 0 0 1 5 0v9a1.5 1.5 0 0 1-3 0V5a.5.5 0 0 1 1 0v7a.5.5 0 0 0 1 0V3a1.5 1.5 0 1 0-3 0v9a2.5 2.5 0 0 0 5 0V5a.5.5 0 0 1 1 0v7a3.5 3.5 0 1 1-7 0z"/>
                </svg>
            </button>

            <div class="transcript-preview" id="transcriptPreview">
                Your words will appear here...
            </div>

            <button class="mic-button" id="micButton" onclick="toggleMic()">ðŸŽ¤</button>

            <div class="status-text" id="statusText">Listening...</div>
        </div>
    </div>
</div>

<script>
    let patientId = null;
    let patientName = null;
    let ws = null;
    let mediaRecorder = null;
    let audioContext = null;
    let isListening = false;
    let audioQueue = [];
    let isPlayingAudio = false;


    window.onload = function() {
        patientId = sessionStorage.getItem('patientId');
        patientName = sessionStorage.getItem('patientName');

        if (patientId && patientName) {
            document.getElementById('verifySection').style.display = 'none';
            document.getElementById('voiceSection').style.display = 'flex';
            document.getElementById('patientInfo').innerHTML =
                `<strong>Welcome back, ${patientName}!</strong> Speak naturally - I'm listening.`;
            initializeVoice();
        }
    };

    document.addEventListener('DOMContentLoaded', function() {
        const fileInput = document.getElementById('fileInput');
        if (fileInput) {
            fileInput.addEventListener('change', uploadDocument);
        }
    });

    function goToChat() {
        window.location.href = './chat.html';
    }

    async function verifyPatient() {
        const mobile = document.getElementById('mobileNumber').value;
        const msgDiv = document.getElementById('verifyMessage');

        if (!mobile) {
            msgDiv.innerHTML = '<p class="error">Please enter mobile number</p>';
            return;
        }

        msgDiv.innerHTML = '<p class="loading">Verifying...</p>';

        try {
            const response = await fetch('../api/v1/verify-patient', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ mobile_number: mobile })
            });

            const data = await response.json();

            if (data.verified) {
                patientId = data.patient_id;
                patientName = data.patient_name;

                // Store in session
                sessionStorage.setItem('patientId', patientId);
                sessionStorage.setItem('patientName', patientName);

                document.getElementById('verifySection').style.display = 'none';
                document.getElementById('voiceSection').style.display = 'flex';
                document.getElementById('patientInfo').innerHTML =
                    `<strong>Welcome, ${patientName}!</strong> Speak naturally - I'm listening.`;

                await initializeVoice();
            } else {
                msgDiv.innerHTML = `<p class="error">${data.message}</p>`;
            }
        } catch (error) {
            msgDiv.innerHTML = '<p class="error">Error verifying patient. Please try again.</p>';
            console.error('Verification error:', error);
        }
    }

    async function initializeVoice() {
        try {
            updateStatus('Requesting microphone access...');

            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            audioContext = new (window.AudioContext || window.webkitAudioContext)();

            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const pathParts = window.location.pathname.split('/').filter(p => p);
            const basePath = pathParts.length > 0 ? `/${pathParts[0]}` : '';

            const wsUrl = `${protocol}//${window.location.host}${basePath}/api/v1/ws/voice/${patientId}`;
            console.log('Connecting to WebSocket:', wsUrl);

            ws = new WebSocket(wsUrl);

            ws.onopen = () => {
                console.log('WebSocket connected');
                setupMediaRecorder(stream);
            };

            ws.onmessage = async (event) => {
                if (event.data instanceof Blob) {
                    audioQueue.push(event.data);
                    if (!isPlayingAudio) {
                        playNextAudio();
                    }
                } else {
                    const data = JSON.parse(event.data);
                    handleWebSocketMessage(data);
                }
            };

            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
                updateStatus('Connection error');
            };

            ws.onclose = () => {
                console.log('WebSocket closed');
                updateStatus('Disconnected');
                document.getElementById('micButton').disabled = true;
            };

        } catch (error) {
            console.error('Initialization error:', error);
            updateStatus('Failed to access microphone');
        }
    }

    function setupMediaRecorder(stream) {
        mediaRecorder = new MediaRecorder(stream, {
            mimeType: 'audio/webm'
        });

        mediaRecorder.ondataavailable = (event) => {
            if (event.data.size > 0 && ws.readyState === WebSocket.OPEN) {
                ws.send(event.data);
            }
        };

        mediaRecorder.onstart = () => {
            console.log('Recording started');
        };

        mediaRecorder.onstop = () => {
            console.log('Recording stopped');
        };
    }

    function handleWebSocketMessage(data) {
        console.log('Message:', data);

        switch(data.type) {
            case 'status':
                updateStatus(data.message);
                if (data.message === 'Listening...') {
                    enableMic();
                }
                break;

            case 'interim_transcript':
                document.getElementById('transcriptPreview').textContent = data.text;
                break;

            case 'transcript':
                document.getElementById('transcriptPreview').textContent = 'Processing...';
                addMessage('user', data.text);
                break;

            case 'response':
                addMessage('assistant', data.text);
                break;

            case 'audio_complete':
                break;

            case 'speech_started':
                console.log('User started speaking');
                break;
        }
    }

    async function playNextAudio() {
        if (audioQueue.length === 0) {
            isPlayingAudio = false;
            return;
        }

        isPlayingAudio = true;
        const audioBlob = audioQueue.shift();

        try {
            const arrayBuffer = await audioBlob.arrayBuffer();
            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

            const source = audioContext.createBufferSource();
            source.buffer = audioBuffer;
            source.connect(audioContext.destination);

            source.onended = () => {
                playNextAudio();
            };

            source.start(0);
        } catch (error) {
            console.error('Error playing audio:', error);
            playNextAudio();
        }
    }

    function toggleMic() {
        if (!isListening) {
            startListening();
        } else {
            stopListening();
        }
    }

    function startListening() {
        if (mediaRecorder && mediaRecorder.state === 'inactive') {
            mediaRecorder.start(100);
            isListening = true;
            document.getElementById('micButton').classList.add('listening');
            document.getElementById('transcriptPreview').textContent = 'Listening...';
            updateStatus('Speak now...');
        }
    }

    function stopListening() {
        if (mediaRecorder && mediaRecorder.state === 'recording') {
            mediaRecorder.stop();
            isListening = false;
            document.getElementById('micButton').classList.remove('listening');
            updateStatus('Processing...');
        }
    }

    function enableMic() {
        const micButton = document.getElementById('micButton');
        micButton.disabled = false;
        document.getElementById('transcriptPreview').textContent = 'Click microphone to speak...';
    }

    function updateStatus(message) {
        document.getElementById('statusText').textContent = message;
    }

    function addMessage(type, text) {
        const conversation = document.getElementById('conversation');
        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${type}`;
        messageDiv.innerHTML = `<div class="message-content">${escapeHtml(text)}</div>`;
        conversation.appendChild(messageDiv);
        conversation.scrollTop = conversation.scrollHeight;
    }

    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    async function uploadDocument(event) {
        const file = event.target.files[0];
        const statusDiv = document.getElementById('uploadStatus');
        const uploadBtn = document.getElementById('uploadBtn');

        if (!file) return;

        if (file.type !== 'application/pdf') {
            statusDiv.innerHTML = '<p class="error">Please upload a PDF file only</p>';
            event.target.value = '';
            return;
        }

        if (file.size > 10 * 1024 * 1024) {
            statusDiv.innerHTML = '<p class="error">File size must be less than 10MB</p>';
            event.target.value = '';
            return;
        }

        uploadBtn.disabled = true;
        addMessage('user', `ðŸ“„ Uploaded: ${file.name}`);

        const formData = new FormData();
        formData.append('file', file);
        formData.append('patient_id', patientId);

        try {
            const response = await fetch('../api/v1/chat/upload-document', {
                method: 'POST',
                body: formData
            });

            if (!response.ok) {
                const data = await response.json();
                const errorMsg = data.detail || `Upload failed: ${response.status}`;
                console.error('Backend error:', data);
                addMessage('assistant', `${errorMsg}`);
                uploadBtn.disabled = false;
                event.target.value = '';
                return;
            }

            const data = await response.json();

            if (data.success) {
                addMessage('assistant', data.explanation);
            } else {
                addMessage('assistant', `${data.message}`);
            }
        } catch (error) {
            addMessage('assistant', 'Error uploading document. Please try again.');
            console.error('Upload error:', error);
        } finally {
            uploadBtn.disabled = false;
            event.target.value = '';
        }
    }

    window.addEventListener('beforeunload', () => {
        if (ws) {
            ws.close();
        }
        if (mediaRecorder && mediaRecorder.state === 'recording') {
            mediaRecorder.stop();
        }
    });
</script>

</body>
</html>